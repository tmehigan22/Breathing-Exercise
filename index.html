<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>4-7-8 Breathing</title>
  <style>
    :root{
      --bg: #2f2f2f;
      --ringTrack: rgba(255,255,255,0.18);

      /* Change #3: darker green made darker */
      --segInhale: #4f7f67;  /* darker */
      --segHold:   #9bbfae;  /* lighter green */
      --segExhale: #e6e3d6;  /* warm off-white */

      --text: rgba(255,255,255,0.85);
      --muted: rgba(255,255,255,0.55);

      --size: min(72vw, 320px);
      --stroke: 14;
      --dot: 16px;
      --dotFill: #d8a3a3; /* pink-ish like screenshot */
      --dotOutline: rgba(0,0,0,0.35);

      --minScale: 0.78;

      /* Change #2: ring grows larger on inhale/hold */
      --maxScale: 1.14;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 22px;
    }

    .calmTitle{
      margin: 0 0 6px 0;
      font-size: 18px;
      font-weight: 500;
      letter-spacing: 0.3px;
      color: rgba(255,255,255,0.75);
      text-align: center;
      line-height: 1.4;
    }

    .wrap{
      width: min(680px, 100%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 16px;
    }

    .vizBox{
      position: relative;
      width: var(--size);
      height: var(--size);
      display:grid;
      place-items:center;
      user-select:none;
    }

    .ringScale{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      transform: scale(var(--minScale));
      transition: transform 120ms linear;
      will-change: transform;
    }

    svg{
      width: 100%;
      height: 100%;
      overflow: visible;
      transform: rotate(-90deg); /* start at 12 o'clock */
    }

    .centerText{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      text-transform: lowercase;
      font-size: 28px;
      letter-spacing: 0.5px;
    }

    .dot{
      position:absolute;
      width: var(--dot);
      height: var(--dot);
      border-radius: 999px;
      background: var(--dotFill);
      border: 2px solid var(--dotOutline);
      left: 0;
      top: 0;

      /* Change #1: smoother motion (GPU transform, no layout writes) */
      transform: translate3d(0,0,0);
      will-change: transform;
      pointer-events:none;
    }

    .hint{
      color: var(--muted);
      font-size: 13px;
      text-align:center;
      line-height: 1.4;
      margin: 0;
    }

    .controls{
      display:flex;
      gap: 10px;
    }

    button{
      appearance:none;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 650;
      letter-spacing: 0.2px;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
    }
    button:hover{
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.30);
    }
    button:active{ transform: translateY(1px); }
    button.primary{
      background: rgba(255,255,255,0.92);
      color: rgba(0,0,0,0.82);
      border-color: rgba(255,255,255,0.60);
    }
    button:disabled{
      opacity: 0.55;
      cursor:not-allowed;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h2 class="calmTitle">It will be okay, stay as long as you need</h2>

    <div class="vizBox" id="vizBox" aria-label="4-7-8 breathing timer">
      <div class="ringScale" id="ringScale">
        <svg viewBox="0 0 200 200" aria-hidden="true">
          <!-- Track -->
          <circle cx="100" cy="100" r="70"
                  fill="none" stroke="var(--ringTrack)"
                  stroke-width="var(--stroke)" stroke-linecap="butt" />

          <!-- Segments (inhale, hold, exhale) -->
          <circle id="segInhale" cx="100" cy="100" r="70"
                  fill="none" stroke="var(--segInhale)"
                  stroke-width="var(--stroke)" stroke-linecap="butt" />
          <circle id="segHold" cx="100" cy="100" r="70"
                  fill="none" stroke="var(--segHold)"
                  stroke-width="var(--stroke)" stroke-linecap="butt" />
          <circle id="segExhale" cx="100" cy="100" r="70"
                  fill="none" stroke="var(--segExhale)"
                  stroke-width="var(--stroke)" stroke-linecap="butt" />
        </svg>
      </div>

      <div class="centerText" id="phaseLabel">inhale</div>
      <div class="dot" id="dot"></div>
    </div>

    <div class="controls">
      <button class="primary" id="startBtn">Start</button>
      <button id="pauseBtn" disabled>Pause</button>
    </div>

    <p class="hint">Inhale 4 seconds • Hold 7 seconds • Exhale 8 seconds</p>
  </div>

  <script>
    const phases = [
      { key: "inhale", label: "inhale", sec: 4 },
      { key: "hold",   label: "hold",   sec: 7 },
      { key: "exhale", label: "exhale", sec: 8 },
    ];
    const totalSec = phases.reduce((a,p)=>a+p.sec,0);

    const vizBox = document.getElementById("vizBox");
    const ringScaleEl = document.getElementById("ringScale");
    const phaseLabelEl = document.getElementById("phaseLabel");
    const dotEl = document.getElementById("dot");

    const startBtn = document.getElementById("startBtn");
    const pauseBtn = document.getElementById("pauseBtn");

    const segInhale = document.getElementById("segInhale");
    const segHold   = document.getElementById("segHold");
    const segExhale = document.getElementById("segExhale");

    // SVG circle geometry
    const svgR = 70;
    const svgC = 2 * Math.PI * svgR;

    function setSegment(circleEl, startFrac, lenFrac) {
      const segLen = svgC * lenFrac;
      const gapLen = svgC - segLen;
      circleEl.style.strokeDasharray = `${segLen} ${gapLen}`;
      circleEl.style.strokeDashoffset = `${-svgC * startFrac}`;
    }

    const inhaleFrac = phases[0].sec / totalSec;
    const holdFrac   = phases[1].sec / totalSec;
    const exhaleFrac = phases[2].sec / totalSec;

    setSegment(segInhale, 0, inhaleFrac);
    setSegment(segHold, inhaleFrac, holdFrac);
    setSegment(segExhale, inhaleFrac + holdFrac, exhaleFrac);

    // Animation state
    let running = false;
    let paused = false;
    let raf = null;

    let t0 = 0;
    let pausedAt = 0;
    let pauseAccum = 0;

    const rootStyles = getComputedStyle(document.documentElement);
    const minScale = parseFloat(rootStyles.getPropertyValue('--minScale')) || 0.78;
    const maxScale = parseFloat(rootStyles.getPropertyValue('--maxScale')) || 1.14;

    function nowMs(){ return performance.now(); }

    function getElapsedSec() {
      const t = nowMs();
      const activeMs = t - t0 - pauseAccum;
      const sec = (activeMs / 1000) % totalSec;
      return sec < 0 ? 0 : sec;
    }

    function phaseFor(sec) {
      let acc = 0;
      for (const p of phases) {
        const start = acc;
        const end = acc + p.sec;
        if (sec >= start && sec < end) {
          return { p, start, end, phaseProgress: (sec - start) / p.sec };
        }
        acc = end;
      }
      const last = phases[phases.length - 1];
      return { p:last, start: totalSec-last.sec, end: totalSec, phaseProgress: 1 };
    }

    function lerp(a,b,t){ return a + (b-a)*t; }

    function setScaleForPhase(key, t) {
      let s = minScale;
      if (key === "inhale") s = lerp(minScale, maxScale, t);
      else if (key === "hold") s = maxScale;
      else if (key === "exhale") s = lerp(maxScale, minScale, t);
      ringScaleEl.style.transform = `scale(${s})`;
      return s;
    }

    // Change #1: cache geometry (no per-frame layout reads)
    let geom = { cx: 0, cy: 0, baseRadius: 0 };
    function recomputeGeometry(){
      const box = vizBox.getBoundingClientRect();
      geom.cx = box.width / 2;
      geom.cy = box.height / 2;
      geom.baseRadius = (Math.min(box.width, box.height) / 2) * (svgR / 100);
    }
    window.addEventListener('resize', recomputeGeometry, { passive: true });

    function placeDot(elapsedFrac, currentScale) {
      const rPx = geom.baseRadius * currentScale;

      // Start at top, clockwise
      const angle = (-Math.PI / 2) + (elapsedFrac * 2 * Math.PI);
      const x = geom.cx + rPx * Math.cos(angle);
      const y = geom.cy + rPx * Math.sin(angle);

      // GPU transform (no layout writes)
      dotEl.style.transform = `translate3d(${(x - dotEl.offsetWidth/2).toFixed(2)}px, ${(y - dotEl.offsetHeight/2).toFixed(2)}px, 0)`;
    }

    function tick() {
      if (!running || paused) return;

      const sec = getElapsedSec();
      const frac = sec / totalSec;

      const { p, phaseProgress } = phaseFor(sec);
      phaseLabelEl.textContent = p.label;

      const scale = setScaleForPhase(p.key, phaseProgress);
      placeDot(frac, scale);

      raf = requestAnimationFrame(tick);
    }

    function start() {
      if (running) return;

      running = true;
      paused = false;
      pauseAccum = 0;
      t0 = nowMs();

      startBtn.disabled = true;
      pauseBtn.disabled = false;
      pauseBtn.textContent = "Pause";

      raf = requestAnimationFrame(tick);
    }

    function pauseToggle() {
      if (!running) return;

      if (!paused) {
        paused = true;
        pausedAt = nowMs();
        pauseBtn.textContent = "Resume";
        if (raf) cancelAnimationFrame(raf);
        raf = null;
      } else {
        paused = false;
        pauseAccum += (nowMs() - pausedAt);
        pauseBtn.textContent = "Pause";
        raf = requestAnimationFrame(tick);
      }
    }

    startBtn.addEventListener("click", start);
    pauseBtn.addEventListener("click", pauseToggle);

    // Initial
    recomputeGeometry();
    (function initPreview(){
      const scale = setScaleForPhase("inhale", 0);
      placeDot(0, scale);
      phaseLabelEl.textContent = "inhale";
    })();
  </script>
</body>
</html>
